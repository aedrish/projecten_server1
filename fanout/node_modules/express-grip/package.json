{
  "name": "express-grip",
  "version": "1.1.0",
  "author": {
    "name": "Fanout, Inc.",
    "email": "info@fanout.io"
  },
  "description": "Express GRIP library",
  "contributors": [
    {
      "name": "Konstantin Bokarius",
      "email": "kon@fanout.io"
    }
  ],
  "main": "./lib/express_grip",
  "repository": {
    "type": "git",
    "url": "https://github.com/fanout/express-grip.git"
  },
  "readmeFilename": "README.md",
  "keywords": [
    "grip",
    "fanout",
    "fanoutpub",
    "realtime",
    "push",
    "pubcontrol",
    "publish",
    "express"
  ],
  "dependencies": {
    "pubcontrol": "1.x",
    "grip": ">=1.2.4 <2.0.0",
    "jwt-simple": "0.x",
    "jspack": "0.x"
  },
  "license": "MIT",
  "readme": "express-grip\n================\n\nAuthor: Konstantin Bokarius <kon@fanout.io>\n\nAn Express GRIP library.\n\nLicense\n-------\n\nexpress-grip is offered under the MIT license. See the LICENSE file.\n\nInstallation\n------------\n\nThis library is compatible with both Express 3 and 4.\n\n```sh\nnpm install express-grip\n```\n\nUsage\n-----\n\nThis library comes with two middleware classes which you must use. Express-grip performs its magic and provides conveniences through the use of both pre-route and post-route middleware. _Therefore, even if a particular route does not use express-grip features, it's necessary to call next() at the end of your route handler to ensure that the post-route middleware executes_. The middleware will parse the Grip-Sig header in any requests to detect if they came from a GRIP proxy, and it will apply any hold instructions when responding. Additionally, the middleware handles WebSocket-Over-HTTP processing so that WebSockets managed by the GRIP proxy can be controlled via HTTP responses from the Express application.\n\nConfigure express-grip by providing a configuration object of your choice to the configure() method. The various express-grip settings are shown below. Note that your configuration object should provide access to the express-grip settings via dot notation. Call the configure() method in your app.js file like so:\n\n```javascript\nvar expressGrip = require('express-grip');\n\nvar myConfigObject = { ... };\n\nexpressGrip.configure(myConfigObject);\n```\n\nSet gripProxies for GRIP proxy validation and publishing:\n\n```javascript\n// Pushpin and/or Fanout.io is used for sending realtime data to clients\nvar myConfigObject = {\n    gripProxies = [\n        // Pushpin\n        {\n            'control_uri': 'http://localhost:5561',\n            'key': 'changeme'\n        },\n        // Fanout.io\n        {\n            'control_uri': 'https://api.fanout.io/realm/your-realm',\n            'control_iss': 'your-realm',\n            'key': Base64.decode64('your-realm-key')\n        }],\n    ...\n};\n```\n\nIf it's possible for clients to access the Express app directly, without necessarily going through the GRIP proxy, then you may want to avoid sending GRIP instructions to those clients. An easy way to achieve this is with the gripProxyRequired setting. If set, then any direct requests that trigger a GRIP instruction response will be given a 501 Not Implemented error instead.\n\n```javascript\nvar myConfigObject = {\n    gripProxyRequired: true,\n    ...\n};\n```\n\nTo prepend a fixed string to all channels used for publishing and subscribing, set gripPrefix in your configuration:\n\n```javascript\nvar myConfigObject = {\n    gripPrefix = '<prefix>',\n    ...\n};\n```\n\nYou can also set any other EPCP servers that aren't necessarily proxies with publishServers:\n\n```javascript\nvar myConfigObject = {\n    gripPubServers = [\n        {\n            'uri': 'http://example.com/base-uri',\n            'iss': 'your-iss', \n            'key': 'your-key'\n        }],\n    ...\n};\n```\n\nExpress 4 example route:\n\n```javascript\nvar express = require('express');\nvar router = express.Router();\nvar grip = require('grip');\nvar expressGrip = require('express-grip');\n\n// Add the pre-handler middleware to the front of the stack\nrouter.use(expressGrip.preHandlerGripMiddleware);\n\nrouter.get('/', function(req, res, next) {\n    try {\n        // If the request didn't come through a GRIP proxy, throw 501\n        if (!res.locals.gripProxied) {\n            res.sendStatus(501);\n            return;\n        }\n     \n        // Subscribe every incoming request to a channel in stream mode\n        expressGrip.setHoldStream(res, '<channel>');\n        res.send('[stream open]\\n');\n\n        // Alternatively subscribe and long-poll\n        //expressGrip.setHoldLongpoll(res, '<channel>', <timeout>);\n        //res.end();\n    } finally {\n        // next() must be called for the post-handler middleware to execute\n        next();\n    }\n});\n\nrouter.post('/', function(req, res, next) {\n    data = req.body;\n\n    // Publish stream data to subscribers\n    expressGrip.publish('<channel>', new grip.HttpStreamFormat(data + '\\n'));\n\n    // Alternatively publish response data to long-poll clients\n    //expressGrip.publish('<channel>',\n    //        new grip.HttpResponseFormat(null, null, null, data));\n\n    res.send('Ok\\n');\n    next();\n});\n\n// Add the post-handler middleware to the back of the stack\nrouter.use(expressGrip.postHandlerGripMiddleware);\n\nmodule.exports = router;\n```\n\nExpress 4 stateless WebSocket echo service example with broadcast endpoint:\n\n```javascript\nvar express = require('express');\nvar router = express.Router();\nvar bodyParser = require('body-parser');\nvar grip = require('grip');\nvar expressGrip = require('express-grip');\n\n// Add the pre-handler middleware to the front of the stack\nrouter.use(expressGrip.preHandlerGripMiddleware);\n\nrouter.all('/websocket', function(req, res, next) {\n    // Reject non-WebSocket requests\n    if (!expressGrip.verifyIsWebSocket(res, next)) {\n        return;\n    }\n\n    // If this is a new connection, accept it and subscribe it to a channel\n    ws = expressGrip.getWsContext(res);\n    if (ws.isOpening()) {\n        ws.accept();\n        ws.subscribe('<channel>');\n    }\n\n    while (ws.canRecv()) {\n        // Note that recv() will always return a String while recvRaw() can be\n        // used to get either a String or Buffer depending on whether the\n        // message is TEXT or BINARY respectively\n        message = ws.recv();\n\n        // If return value is undefined then connection is closed\n        if (message == null) {\n            ws.close();\n            break;\n        }\n\n        // Echo the message\n        ws.send(message);\n    }\n\n    // next() must be called for the post-handler middleware to execute\n    next();\n});\n\nrouter.post('/broadcast',\n        bodyParser.text({ type: '*/*' }),\n        function(req, res, next) {\n    // Publish data to all clients that are connected to the echo endpoint\n    data = req.body;\n    expressGrip.publish('<channel>', new grip.WebSocketMessageFormat(data));\n    res.send('Ok\\n');\n\n    // next() must be called for the post-handler middleware to execute\n    next();\n});\n\n// Add the post-handler middleware to the back of the stack\nrouter.use(expressGrip.postHandlerGripMiddleware);\n\nmodule.exports = router;\n```\n",
  "bugs": {
    "url": "https://github.com/fanout/express-grip/issues"
  },
  "_id": "express-grip@1.1.0",
  "dist": {
    "shasum": "578c7a3c3213aab4b4a6dc3eecfaa907f5d6d371"
  },
  "_from": "express-grip@latest",
  "_resolved": "https://registry.npmjs.org/express-grip/-/express-grip-1.1.0.tgz"
}
